Nama : Nadinda Aurora \ NIM : 121450004 \ KELAS : RA

# Tiga cara menyimpan dan mengakses banyak gambar dengan python
Artikel tersebut membahas berbagai cara untuk menyimpan dan mengakses banyak gambar menggunakan Python, dengan fokus pada tiga metode utama: menyimpan gambar ke disk sebagai file PNG atau JPEG, menyimpan gambar dalam database LMDB, dan menyimpan gambar dalam format data hierarkis HDF5. Artikel tersebut juga membahas alasan mengapa metode penyimpanan alternatif perlu dipertimbangkan dan melakukan perbandingan performa antara metode tersebut.

#### Hal - hal yang dilakukan dalam artikel ini :
- Menyimpan gambar pada disk sebagai .pngfile
- Menyimpan gambar dalam database yang dipetakan memori petir (LMDB)
- Menyimpan gambar dalam format data hierarki (HDF5)

#### Hal yang perlu dicari :
- Mengapa metode penyimpanan alternatif patut dipertimbangkan
- Apa perbedaan performa saat Anda membaca dan menulis gambar tunggal
- Apa perbedaan performa saat Anda membaca dan menulis banyak gambar
- Bagaimana perbandingan ketiga metode dalam hal penggunaan disk

Untuk artikel ini, yang penting adalah memiliki pemahaman dasar yang cukup tentang bahasa Python dan gambar (yaitu bahwa gambar sebenarnya dibentuk oleh larik-larik multidimensi angka) serta memahami perbedaan memori relatif, seperti perbedaan antara 10MB dan 10GB.

## Setup
### A Dataset to Play With
Dataset yang akan digunakan dalam artikel ini adalah CIFAR-10, yang merupakan singkatan dari Canadian Institute for Advanced Research. Dataset ini terdiri dari 60.000 gambar berwarna dengan ukuran 32x32 piksel masing-masing. Gambar-gambar ini diklasifikasikan ke dalam berbagai kelas objek, seperti anjing, kucing, dan pesawat terbang. Meskipun CIFAR-10 tidak termasuk dalam kategori dataset yang sangat besar, namun jika kita menggunakan dataset TinyImages yang lebih lengkap, maka kita akan membutuhkan sekitar 400GB ruang disk yang kosong, yang mungkin menjadi kendala yang signifikan.

```
import numpy as np
import pickle
from pathlib import Path
# Path to the unzipped CIFAR data
data_dir = Path("data/cifar-10-batches-py/")
# Unpickle function provided by the CIFAR hosts
def unpickle(file):
    with open(file, "rb") as fo:
        dict = pickle.load(fo, encoding="bytes")
    return dict
images, labels = [], []
for batch in data_dir.glob("data_batch_*"):
    batch_data = unpickle(batch)
    for i, flat_im in enumerate(batch_data[b"data"]):
        im_channels = []
        # Each image is flattened, with channels in order of R, G, B
        for j in range(3):
            im_channels.append(
                flat_im[j * 1024 : (j + 1) * 1024].reshape((32, 32))
            )
        # Reconstruct the original image
        images.append(np.dstack((im_channels)))
        # Save the label
        labels.append(batch_data[b"labels"][i])
print("Loaded CIFAR-10 training set:")
print(f" - np.shape(images)     {np.shape(images)}")
print(f" - np.shape(labels)     {np.shape(labels)}")
```

### Setup for Storing Images on Disk
Berikut membahas tentang persiapan lingkungan untuk menyimpan dan mengakses gambar dari disk menggunakan Python. Memanipulasi gambar dengan `pillow` :
```
$ pip install Pillow
```
Penginstallan menggunakan `anaconda` :
```
$ conda install -c conda-forge pillow
```
PIL (Python Imaging Library) adalah versi asli dari perpustakaan pengolahan gambar Python, namun tidak lagi dipelihara dan tidak kompatibel dengan Python 3.x.
Penting untuk menghapus instalasi PIL sebelum menginstal Pillow, karena keduanya tidak dapat berjalan bersama.
Setelah menginstal Pillow, lingkungan Anda akan siap untuk menyimpan dan membaca gambar dari disk menggunakan Python.

### Getting Started With LMDB
LMDB, kadang disebut sebagai "Lightning Database," merupakan singkatan dari Lightning Memory-Mapped Database karena kecepatannya dan menggunakan file yang dipetakan memori. Ini adalah penyimpanan kunci-nilai, bukan database relasional. Dari segi implementasi, LMDB adalah B+ tree, yang pada dasarnya berarti bahwa itu adalah struktur grafik mirip pohon yang disimpan di dalam memori di mana setiap elemen kunci-nilai adalah sebuah node, dan node dapat memiliki banyak anak. Node pada tingkat yang sama saling terhubung satu sama lain untuk traversing cepat. Secara kritis, komponen kunci dari B+ tree diatur untuk sesuai dengan ukuran halaman dari sistem operasi host, memaksimalkan efisiensi saat mengakses pasangan kunci-nilai apa pun dalam basis data. Karena kinerja LMDB sangat bergantung pada poin ini, efisiensi LMDB telah terbukti bergantung pada sistem file yang mendasarinya dan implementasinya. Alasan lain yang kunci untuk efisiensi LMDB adalah bahwa itu dipetakan memori. Ini berarti bahwa itu mengembalikan pointer langsung ke alamat memori dari kunci dan nilai, tanpa perlu menyalin apa pun di memori seperti yang dilakukan sebagian besar database lain.
```
$ pip install lmdb
```
Penginstalannya melalui `anaconda` :
```
$ conda install -c conda-forge python-lmdb
```
Pemeriksaan melalui `import lmdb` dari shell Python.

### Getting Started With HDF5
HDF5 (Hierarchical Data Format version 5) adalah sebuah format file yang dirancang untuk menyimpan dan mengelola data besar dan kompleks. Format ini digunakan secara luas dalam bidang ilmiah dan teknis, terutama di bidang seperti pemodelan iklim, analisis data geospasial, fisika partikel, dan bioinformatika.
#### File HDF terdiri dari 2 jenis objek :
- Kumpulan data
- Grup

Datasets (Kumpulan Data): Dataset dalam HDF5 adalah larik multidimensi yang menyimpan data. Mereka bisa memiliki dimensi yang bervariasi dan dapat berupa tipe data apa pun. Namun, penting untuk dicatat bahwa dimensi dan tipe data harus seragam di dalam satu dataset. Dengan kata lain, setiap dataset harus berisi larik N-dimensi yang homogen.
Groups (Grup): Grup dalam HDF5 adalah kumpulan dataset atau grup lainnya. Ini memungkinkan untuk menyusun dataset ke dalam struktur hirarkis yang kompleks. Meskipun dataset harus homogen, grup dapat mengandung berbagai jenis dataset dan grup lainnya. Ini berarti bahwa meskipun dataset harus seragam, struktur hirarkis grup memungkinkan untuk heterogenitas yang diperlukan dalam pengorganisasian dan penyimpanan data.
```
$ pip install h5py
```
Penginstalannya melalui `anaconda` :
```
$ conda install -c conda-forge h5py
```
Pemeriksaan melakukan `import h5py` dari shell Python.

## Storing a Single Image
Pada artikel terdapat perbandingan kuantitatif dari tugas-tugas dasar yang penting yakni
Kecepatan: Berapa lama waktu yang dibutuhkan untuk mengakses dan menyimpan gambar menggunakan setiap metode?
Efisiensi Penyimpanan: Berapa banyak ruang disk yang digunakan gambar di bawah setiap metode?
Melalui pengukuran ini, kita akan mendapatkan pemahaman yang lebih baik tentang bagaimana metode penyimpanan yang berbeda bekerja. Perlu diingat bahwa teks ini menggunakan istilah "file" untuk merujuk pada banyak file secara umum. Untuk eksperimen ini, kita akan membandingkan kinerja metode penyimpanan dengan menggunakan berbagai jumlah file, mulai dari satu gambar hingga 100.000 gambar.
Pembuatan folder yang berisi file atau gambar databse dan disimpan jalur direktori ke variabel
```
from pathlib import Path
disk_dir = Path("data/disk/")
lmdb_dir = Path("data/lmdb/")
hdf5_dir = Path("data/hdf5/")
```
`Path` tidak secara otomatis membuat folder kecuali ada permintaan khusus
```
disk_dir.mkdir(parents=True, exist_ok=True)
lmdb_dir.mkdir(parents=True, exist_ok=True)
hdf5_dir.mkdir(parents=True, exist_ok=True)
```
Menjalankan eksperimen menggunakan `timeitmodul`, yang terdapat dalam pustaka standar Python dalam mengatur waktu eksperimen. 

#### Storing to Disk
Pada percobaan ini ada satu gambar `image`, di memori sebagai array NumPy. Penyimpanan ke disk sebagai `.pngimage`, penamaan dengan image ID yang unik `image_id`. Penggunaan `Pillow` pada paket
```
from PIL import Image
import csv
def store_single_disk(image, image_id, label):
    """ Stores a single image as a .png file on disk.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    Image.fromarray(image).save(disk_dir / f"{image_id}.png")
    with open(disk_dir / f"{image_id}.csv", "wt") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        writer.writerow([label])
```
Mengkodekan Label ke Dalam Nama Gambar akan Membutuhkan penanganan semua file setiap kali berurusan dengan label.serta Sulit untuk mengelola label secara terpisah dari gambar.
Menyimpan Label dalam File Terpisah (.csv) akan Membutuhkan file tambahan.
### Storing to LMDB
LMDB menyimpan data sebagai array byte yang efisien dan mudah diakses. LMDB menggunakan sistem nilai-kunci yang memungkinkan penyimpanan gambar dengan pengidentifikasi unik. LMDB mendukung penyimpanan data meta gambar bersama dengan gambar itu sendiri. Untuk menyimpan gambar ke LMDB, ikuti langkah-langkah berikut:
Buat kelas Python untuk gambar dan meta datanya: Buat kelas Python yang mendefinisikan struktur data untuk menyimpan gambar dan meta datanya.
Serialisasi data gambar dan meta data: Gunakan modul pickle untuk mengubah data gambar dan meta data menjadi string yang dapat disimpan dalam LMDB.
Simpan data ke LMDB: Buka database LMDB dan simpan kunci (pengidentifikasi unik) dan nilai (data gambar dan meta data yang diserialisasi) ke dalam database.
```
class CIFAR_Image:
    def __init__(self, image, label):
        # Dimensions of image for reconstruction - not really necessary 
        # for this dataset, but some datasets may include images of 
        # varying sizes
        self.channels = image.shape[2]
        self.size = image.shape[:2]
        self.image = image.tobytes()
        self.label = label
    def get_image(self):
        """ Returns the image as a numpy array. """
        image = np.frombuffer(self.image, dtype=np.uint8)
        return image.reshape(*self.size, self.channels)
```
Meskipun LMDB menawarkan efisiensi penyimpanan gambar, penting untuk mempertimbangkan beberapa faktor:
Menentukan ukuran peta (map_size)
Penggunaan transaksi
Penyimpanan satu gambar ke LMDB :
```
import lmdb
import pickle
def store_single_lmdb(image, image_id, label):
    """ Stores a single image to a LMDB.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    map_size = image.nbytes * 10
    # Create a new LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), map_size=map_size)
    # Start a new write transaction
    with env.begin(write=True) as txn:
        # All key-value pairs need to be strings
        value = CIFAR_Image(image, label)
        key = f"{image_id:08}"
        txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()
```
### Storing With HDF5
HDF5 berisi lebih dari satu kumpulan data. Pembuatan 2 himpunan data, satu gambar dan satu meta data.
```
import h5py
def store_single_hdf5(image, image_id, label):
    """ Stores a single image to an HDF5 file.
        Parameters:
        ---------------
        image       image array, (32, 32, 3) to be stored
        image_id    integer unique ID for image
        label       image label
    """
    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "w")
    # Create a dataset in the file
    dataset = file.create_dataset(
        "image", np.shape(image), h5py.h5t.STD_U8BE, data=image
    )
    meta_set = file.create_dataset(
        "meta", np.shape(label), h5py.h5t.STD_U8BE, data=label
    )
    file.close()
```
`h5py.h5t.STD_U8BE` penentuan jenis data tersimpan pada kumpulan data yaitu  bilangan bulat 8-bit yang tidak ditandatangani.

### Experiments for Storing a Single Image
Kegunaan tiga fungsi dalam menyimpan satu gambar ke dalam `dictionary`. 
```
_store_single_funcs = dict(
    disk=store_single_disk, lmdb=store_single_lmdb, hdf5=store_single_hdf5
)
```
Penyimpanan gambar pertama dari CIFAR dan label terkait dan 3 cara berbeda
```
from timeit import timeit
store_single_timings = dict()
for method in ("disk", "lmdb", "hdf5"):
    t = timeit(
        "_store_single_funcs[method](image, 0, label)",
        setup="image=images[0]; label=labels[0]",
        number=1,
        globals=globals(),
    )
    store_single_timings[method] = t
    print(f"Method: {method}, Time usage: {t}")
```
Terdapat kesimpulan yakni
Semua metode penyimpanan gambar yang diuji cukup cepat.
LMDB menggunakan lebih banyak ruang disk dibandingkan metode lain.
Format gambar yang disimpan secara langsung di disk memiliki beberapa kelebihan:
Dapat dibaca manusia: Format gambar seperti JPEG atau PNG dapat dilihat dan dipahami tanpa memerlukan perangkat lunak khusus.
Mudah diakses: Gambar dapat dibuka dan dilihat langsung dari browser sistem file, tanpa memerlukan database tambahan.
Mempertimbangkan faktor-faktor ini, menyimpan gambar secara langsung di disk mungkin masih menjadi pilihan yang lebih praktis untuk banyak kasus.

## Storing Many Images
### Adjusting the Code for Many Images
Menyimpan banyak gambar sebagai file .png semudah memanggil fungsi store_single_method() berulang kali. Untuk LMDB dan HDF5, Penyimpanan semua gambar ke dalam satu atau beberapa file database daripada membuat file terpisah untuk setiap gambar. Tiga fungsi baru dibuat untuk menangani penyimpanan banyak gambar: store_many_disk(), store_many_lmdb(), dan store_many_hdf5().
```
store_many_disk(images, labels):
    """ Stores an array of images to disk
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)
    # Save all the images one by one
    for i, image in enumerate(images):
        Image.fromarray(image).save(disk_dir / f"{i}.png")
    # Save all the labels to the csv file
    with open(disk_dir / f"{num_images}.csv", "w") as csvfile:
        writer = csv.writer(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for label in labels:
            # This typically would be more than just one value per row
            writer.writerow([label])
def store_many_lmdb(images, labels):
    """ Stores an array of images to LMDB.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)
    map_size = num_images * images[0].nbytes * 10
    # Create a new LMDB DB for all the images
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), map_size=map_size)
    # Same as before â€” but let's write all the images in a single transaction
    with env.begin(write=True) as txn:
        for i in range(num_images):
            # All key-value pairs need to be Strings
            value = CIFAR_Image(images[i], labels[i])
            key = f"{i:08}"
            txn.put(key.encode("ascii"), pickle.dumps(value))
    env.close()
def store_many_hdf5(images, labels):
    """ Stores an array of images to HDF5.
        Parameters:
        ---------------
        images       images array, (N, 32, 32, 3) to be stored
        labels       labels array, (N, 1) to be stored
    """
    num_images = len(images)
    # Create a new HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "w")
    # Create a dataset in the file
    dataset = file.create_dataset(
        "images", np.shape(images), h5py.h5t.STD_U8BE, data=images
    )
    meta_set = file.create_dataset(
        "meta", np.shape(labels), h5py.h5t.STD_U8BE, data=labels
    )
    file.close()
```
Metode File Gambar: Kode diubah untuk mengulang setiap gambar dalam daftar untuk menyimpannya ke disk.
LMDB: Loop diperlukan untuk membuat objek CIFAR_Image untuk setiap gambar dan meta datanya sebelum menyimpannya ke LMDB.
HDF5: Hampir tidak ada penyesuaian yang diperlukan untuk metode HDF5 karena file HDF5 tidak memiliki batasan ukuran file internal. Semua gambar dimasukkan ke dalam satu kumpulan data.

### Preparing the Dataset
Penggandaan ukuran kumpulan data,Pengujian hingga 100.000 gambar:
```
cutoffs = [10, 100, 1000, 10000, 100000]
# Let's double our images so that we have 100,000
images = np.concatenate((images, images), axis=0)
labels = np.concatenate((labels, labels), axis=0)
# Make sure you actually have 100,000 images and labels
print(np.shape(images))
print(np.shape(labels))
```
### Experiment for Storing Many Images
Pembuatan dictionary dalam menangani fungsi `store_many_` :
```
_store_many_funcs = dict(
    disk=store_many_disk, lmdb=store_many_lmdb, hdf5=store_many_hdf5
)
from timeit import timeit
store_many_timings = {"disk": [], "lmdb": [], "hdf5": []}
for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_store_many_funcs[method](images_, labels_)",
            setup="images_=images[:cutoff]; labels_=labels[:cutoff]",
            number=1,
            globals=globals(),
        )
        store_many_timings[method].append(t)
        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, Time usage: {t}")
```
Menyimpan 111.110 gambar tiga kali dengan format berbeda membutuhkan waktu dan ruang disk yang signifikan. Grafik pertama menunjukkan waktu penyimpanan total untuk semua metode. Perbedaan waktu penyimpanan antara .png dan LMDB/HDF5 sangat besar. Grafik kedua menunjukkan perubahan waktu penyimpanan dalam skala log. HDF5 awalnya lebih lambat daripada LMDB, tetapi menjadi lebih cepat untuk kumpulan data yang lebih besar. LMDB dan HDF5 menawarkan performa penyimpanan yang lebih baik dibandingkan .png.
Kode untuk grafik :
```
import matplotlib.pyplot as plt
def plot_with_legend(
    x_range, y_data, legend_labels, x_label, y_label, title, log=False
):
    """ Displays a single plot with multiple datasets and matching legends.
        Parameters:
        --------------
        x_range         list of lists containing x data
        y_data          list of lists containing y values
        legend_labels   list of string legend labels
        x_label         x axis label
        y_label         y axis label
    """
    plt.style.use("seaborn-whitegrid")
    plt.figure(figsize=(10, 7))
    if len(y_data) != len(legend_labels):
        raise TypeError(
            "Error: number of data sets does not match number of labels."
        )
    all_plots = []
    for data, label in zip(y_data, legend_labels):
        if log:
            temp, = plt.loglog(x_range, data, label=label)
        else:
            temp, = plt.plot(x_range, data, label=label)
        all_plots.append(temp)
    plt.title(title)
    plt.xlabel(x_label)
    plt.ylabel(y_label)
    plt.legend(handles=all_plots)
    plt.show()
# Getting the store timings data to display
disk_x = store_many_timings["disk"]
lmdb_x = store_many_timings["lmdb"]
hdf5_x = store_many_timings["hdf5"]
plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Storage time",
    log=False,
)
plot_with_legend(
    cutoffs,
    [disk_x, lmdb_x, hdf5_x],
    ["PNG files", "LMDB", "HDF5"],
    "Number of images",
    "Seconds to store",
    "Log storage time",
    log=True,
)
```
## Reading a Single Image
### Reading From Disk
Membaca gambar dari disk lebih mudah untuk file .png daripada format lain karena tidak memerlukan deserialisasi.
LMDB memerlukan langkah deserialisasi tambahan saat membaca gambar dari memori.
HDF5 memiliki struktur data yang kompleks, sehingga memerlukan beberapa langkah untuk mengekstrak gambar dan meta datanya.
Pembacaan satu gambar dan meta dari `.png` dan `.csv` :
```
def read_single_disk(image_id):
    """ Stores a single image to disk.
        Parameters:
        ---------------
        image_id    integer unique ID for image
        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    image = np.array(Image.open(disk_dir / f"{image_id}.png"))
    with open(disk_dir / f"{image_id}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        label = int(next(reader)[0])
    return image, label
```
### Reading From LMDB
Pembacaan gambar dan meta sama dari LMDB melalui Pembukaan lingkungan dan transaksi baca :
```
def read_single_lmdb(image_id):
    """ Stores a single image to LMDB.
        Parameters:
        ---------------
        image_id    integer unique ID for image
        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the LMDB environment
    env = lmdb.open(str(lmdb_dir / f"single_lmdb"), readonly=True)
    # Start a new read transaction
    with env.begin() as txn:
        # Encode the key the same way as we stored it
        data = txn.get(f"{image_id:08}".encode("ascii"))
        # Remember it's a CIFAR_Image object that is loaded
        cifar_image = pickle.loads(data)
        # Retrieve the relevant bits
        image = cifar_image.get_image()
        label = cifar_image.label
    env.close()
    return image, label
```
### Reading From HDF5
Pembukaan dan pembacaan file HDF5 dan penguraian gambar dan meta
```
def read_single_hdf5(image_id):
    """ Stores a single image to HDF5.
        Parameters:
        ---------------
        image_id    integer unique ID for image
        Returns:
        ----------
        image       image array, (32, 32, 3) to be stored
        label       associated meta data, int label
    """
    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{image_id}.h5", "r+")
    image = np.array(file["/image"]).astype("uint8")
    label = int(np.array(file["/meta"]).astype("uint8"))
    return image, label
```
Pembuatan kamus yang berisi fungsi baca : 
```
_read_single_funcs = dict(
    disk=read_single_disk, lmdb=read_single_lmdb, hdf5=read_single_hdf5
)
```

### Experiment for Reading a Single Image
Penampilan kode eksperimen 
```
from timeit import timeit
read_single_timings = dict()
for method in ("disk", "lmdb", "hdf5"):
    t = timeit(
        "_read_single_funcs[method](0)",
        setup="image=images[0]; label=labels[0]",
        number=1,
        globals=globals(),
    )
    read_single_timings[method] = t
    print(f"Method: {method}, Time usage: {t}")
```
Membaca dari disk (.png) adalah yang tercepat. Hal ini karena file .png tidak memerlukan deserialisasi, sehingga proses pembacanya lebih sederhana. LMDB berada di urutan kedua. Meskipun memerlukan deserialisasi, LMDB masih menunjukkan kinerja yang cukup cepat. HDF5 adalah yang paling lambat. Hal ini disebabkan oleh struktur datanya yang lebih kompleks yang membutuhkan beberapa langkah untuk mengekstrak gambar dan meta datanya.
## Reading Many Images
### Adjusting the Code for Many Images
Pembuatan fungsi read_many_ yang dipakai dalam : 
```
def read_many_disk(num_images):
    """ Reads image from disk.
        Parameters:
        ---------------
        num_images   number of images to read
        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []
    # Loop over all IDs and read each image in one by one
    for image_id in range(num_images):
        images.append(np.array(Image.open(disk_dir / f"{image_id}.png")))
    with open(disk_dir / f"{num_images}.csv", "r") as csvfile:
        reader = csv.reader(
            csvfile, delimiter=" ", quotechar="|", quoting=csv.QUOTE_MINIMAL
        )
        for row in reader:
            labels.append(int(row[0]))
    return images, labels
def read_many_lmdb(num_images):
    """ Reads image from LMDB.
        Parameters:
        ---------------
        num_images   number of images to read
        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []
    env = lmdb.open(str(lmdb_dir / f"{num_images}_lmdb"), readonly=True)
    # Start a new read transaction
    with env.begin() as txn:
        # Read all images in one single transaction, with one lock
        # We could split this up into multiple transactions if needed
        for image_id in range(num_images):
            data = txn.get(f"{image_id:08}".encode("ascii"))
            # Remember that it's a CIFAR_Image object 
            # that is stored as the value
            cifar_image = pickle.loads(data)
            # Retrieve the relevant bits
            images.append(cifar_image.get_image())
            labels.append(cifar_image.label)
    env.close()
    return images, labels
def read_many_hdf5(num_images):
    """ Reads image from HDF5.
        Parameters:
        ---------------
        num_images   number of images to read
        Returns:
        ----------
        images      images array, (N, 32, 32, 3) to be stored
        labels      associated meta data, int label (N, 1)
    """
    images, labels = [], []
    # Open the HDF5 file
    file = h5py.File(hdf5_dir / f"{num_images}_many.h5", "r+")
    images = np.array(file["/images"]).astype("uint8")
    labels = np.array(file["/meta"]).astype("uint8")
    return images, labels
_read_many_funcs = dict(
    disk=read_many_disk, lmdb=read_many_lmdb, hdf5=read_many_hdf5
)
```
### Experiment for Reading Many Images
Pembacaan banyak gambar : 
```
from timeit import timeit
read_many_timings = {"disk": [], "lmdb": [], "hdf5": []}
for cutoff in cutoffs:
    for method in ("disk", "lmdb", "hdf5"):
        t = timeit(
            "_read_many_funcs[method](num_images)",
            setup="num_images=cutoff",
            number=1,
            globals=globals(),
        )
        read_many_timings[method].append(t)
        # Print out the method, cutoff, and elapsed time
        print(f"Method: {method}, No. images: {cutoff}, Time usage: {t}")
```
Kecepatan Baca: .png: Format ini menawarkan kecepatan baca tercepat untuk gambar tunggal. HDF5: Format ini menunjukkan kinerja baca yang lebih baik untuk kumpulan data besar. LMDB: Format ini memiliki kecepatan baca yang lebih cepat dibandingkan .png untuk kumpulan data yang lebih besar, namun lebih lambat dibandingkan HDF5.
Kecepatan Tulis: .png: Format ini menawarkan kecepatan tulis yang cepat. LMDB dan HDF5: Format ini memiliki kecepatan tulis yang lebih lambat dibandingkan .png.
Penggunaan Disk: .png: Format ini memiliki ukuran file yang lebih kecil untuk gambar tunggal. LMDB dan HDF5: Format ini menawarkan penggunaan disk yang lebih efisien secara keseluruhan karena struktur datanya yang lebih kompak.
## Considering Disk Usage
Ruang disk menjadi pertimbangan penting untuk kumpulan data besar. Menyimpan salinan kumpulan data gambar dalam format alternatif dapat meningkatkan kinerja baca/tulis, tetapi membutuhkan ruang disk tambahan. LMDB dan HDF5 menawarkan kompresi yang lebih baik. Format ini dapat mengurangi ukuran file gambar secara signifikan, sehingga menghemat ruang disk. .png tidak memiliki kompresi bawaan. Format ini menghasilkan file gambar yang lebih besar, sehingga membutuhkan lebih banyak ruang disk. Perlu mempertimbangkan ruang disk yang tersedia. Sebelum memilih format penyimpanan, pastikan memiliki cukup ruang disk untuk menyimpan salinan kumpulan data gambar.
**Berapa banyak ruang disk yang digunakan berbagai metode penyimpanan?**
Penampilan ruang disk dengan code sebagai berikut :
```
# Memory used in KB
disk_mem = [24, 204, 2004, 20032, 200296]
lmdb_mem = [60, 420, 4000, 39000, 393000]
hdf5_mem = [36, 304, 2900, 29000, 293000]
X = [disk_mem, lmdb_mem, hdf5_mem]
ind = np.arange(3)
width = 0.35
plt.subplots(figsize=(8, 10))
plots = [plt.bar(ind, [row[0] for row in X], width)]
for i in range(1, len(cutoffs)):
    plots.append(
        plt.bar(
            ind, [row[i] for row in X], width, bottom=[row[i - 1] for row in X]
        )
    )
plt.ylabel("Memory in KB")
plt.title("Disk memory used by method")
plt.xticks(ind, ("PNG", "LMDB", "HDF5"))
plt.yticks(np.arange(0, 400000, 100000))
plt.legend(
    [plot[0] for plot in plots], ("10", "100", "1,000", "10,000", "100,000")
)
plt.show()
```
LMDB dan HDF5 menggunakan lebih banyak ruang disk daripada .png. Hal ini karena struktur data yang lebih kompleks dan kompresi data yang lebih baik.
Efisiensi disk LMDB bergantung pada ukuran gambar. Untuk gambar kecil, LMDB efisien karena memanfaatkan caching dan ukuran halaman OS. Untuk gambar besar, LMDB menjadi kurang efisien karena gambar tidak muat di halaman daun, sehingga membutuhkan banyak halaman meluap.
HDF5 umumnya lebih efisien dalam penggunaan disk daripada LMDB untuk gambar besar. Hal ini karena algoritma kompresi HDF5 yang lebih baik.
Ukuran gambar dan faktor lain memengaruhi penggunaan disk. Sistem operasi dan struktur data gambar juga dapat memengaruhi efisiensi disk.

## Discussion
### Parallel Access
Akses Paralel:
.png: Format ini ideal untuk aplikasi yang memerlukan akses paralel penuh, karena pembacaan dan penulisan file gambar independen.
LMDB: Format ini memungkinkan beberapa pembaca secara bersamaan, tetapi aksesnya tidak sepenuhnya paralel. Hal ini dapat bermanfaat untuk aplikasi yang memerlukan pembacaan bersamaan, tetapi tidak memerlukan akses paralel penuh.
HDF5: Format ini mendukung I/O paralel, tetapi aksesnya tidak sepenuhnya paralel. Membagi kumpulan data menjadi beberapa file HDF5 dapat meningkatkan kinerja akses paralel.
## Conclusion
Telah diperkenalkan oleh artikel mengenai cara menyimpan dan mengakses banyak gambar melalui Python.
Tiga metode penyimpanan gambar telah dibahas: .png, LMDB, dan HDF5.
Ketiga metode memiliki kelebihan dan kekurangannya masing-masing:
.png: Mudah digunakan, hemat ruang disk, tetapi memiliki waktu baca/tulis yang lambat.
LMDB: Kinerja baca/tulis cepat, tetapi penggunaan ruang disk lebih besar dan akses paralel terbatas.
HDF5: Kinerja baca/tulis cepat, kompresi data yang baik, tetapi implementasi akses paralel lebih kompleks.
Format Penyimpanan
Kumpulan data kecil: .png mungkin cukup.
Kumpulan data besar, kinerja baca/tulis penting: LMDB atau HDF5.
Kumpulan data besar, akses paralel penting: HDF5 dengan pembagian data.
